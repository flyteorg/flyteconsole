import { useNodeExecutions, useWorkflow } from 'components/hooks';
import { Workflow } from 'models';
import { useContext, useMemo } from 'react';
import { ExecutionContext } from './contexts';
import { NodeExecutionGroup } from './types';
import { mapNodeExecutionDetails } from './utils';

/** Decorates a fetchable list of NodeExecutions generated by `useNodeExecutions`,
 * mapping the list items to `DetailedNodeExecution`s. The node details are
 * pulled from the closure of a fetchable `Workflow`.
 * Note: This hook can generate output without a valid workflow value (i.e. before
 * the workflow has finished fetching). It is the responsibility of calling code
 * to use `waitForData` or `waitForAllFetchables` to prevent display of the
 * output if this would be undesirable.
 */
export function useDetailedNodeExecutions(
    nodeExecutionsFetchable: ReturnType<typeof useNodeExecutions>,
    workflowFetchable?: ReturnType<typeof useWorkflow>
) {
    const { dataCache } = useContext(ExecutionContext);
    // TODO: This could be updated to use fetch functions directly
    const { value: nodeExecutions } = nodeExecutionsFetchable;
    let workflow: Workflow | undefined = undefined;
    if (workflowFetchable && workflowFetchable.hasLoaded) {
        workflow = workflowFetchable.value;
    }

    return {
        ...nodeExecutionsFetchable,
        value: useMemo(
            () => mapNodeExecutionDetails(nodeExecutions, dataCache),
            [nodeExecutions, workflow, dataCache]
        )
    };
}

export function useDetailedChildNodeExecutions(
    nodeExecutionGroups: NodeExecutionGroup[]
) {
    const { dataCache } = useContext(ExecutionContext);
    return useMemo(
        () =>
            nodeExecutionGroups.map(group => ({
                ...group,
                nodeExecutions: mapNodeExecutionDetails(
                    group.nodeExecutions,
                    dataCache
                )
            })),
        [nodeExecutionGroups, dataCache]
    );
}
